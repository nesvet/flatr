# ğŸ¥ fln

[![CI](https://github.com/nesvet/fln/actions/workflows/ci.yaml/badge.svg)](https://github.com/nesvet/fln/actions/workflows/ci.yaml)
[![npm](https://img.shields.io/npm/v/fln)](https://www.npmjs.com/package/fln)
[![license](https://img.shields.io/npm/l/fln)](LICENSE)

**Your entire codebase â†’ One AI-ready file.**

Stop wrestling with file pickers and attachment limits â€” feed your whole project to any LLM in one shot.

```bash
fln .
```

Or run instantly:

```bash
npx fln . -o codebase.md
```

Works with **Claude**, **ChatGPT**, **Gemini**, **Grok**, **Cursor**, **Copilot**, and *any* AI tool.

**`fln`** (short for *flatten*) is **language-agnostic** by design: TypeScript, Python, Java, Go, Rust, Bash, SQL, mixed monorepos â€” it treats everything as plain text, detects project metadata from common manifests (`package.json`, `pyproject.toml`, `go.mod`, `Cargo.toml`, `CMakeLists.txt`, `vcpkg.json`), respects `.gitignore`, and skips binaries by default.

## Why fln exists

If you use LLMs for real projects, youâ€™ve hit these limits:

- **Context windows** â€” large projects donâ€™t fit.
- **Upload friction** â€” selecting dozens of files for every session.
- **Partial understanding** â€” AI sees fragments, not the architecture.
- **Manual prep** â€” repeating the same setup context again and again.

**`fln` removes that overhead.**  
It turns your project into a single, structured snapshot that LLMs can actually reason about.

## What fln enables

**â†’ Full-context refactoring**  
Ask architectural questions that are impossible file-by-file:
> â€œWhere is the real coupling here?â€  
> â€œWhat should be split into modules?â€

**â†’ Instant onboarding**  
One markdown file instead of â€œstart by opening these 12 foldersâ€. Perfect for reading code on a tablet or onboarding new developers without an IDE.

**â†’ Project-level code reviews**  
Let AI detect patterns, inconsistencies, and risks across the entire codebase.

**â†’ Auditable Snapshots**  
Create a single, clean artifact of your codebase state for security reviews, compliance audits, or legal records without granting full repo access.

**â†’ Dataset Preparation**  
Generate clean, formatted data for RAG pipelines and fine-tuning custom models.

**â†’ LLM-friendly diffs**  
Flatten â†’ commit â†’ flatten again. See how the *whole project* changed structurally.

## Compatible with your AI workflow

- **Claude** â€” ideal for large architectural prompts (200K+ tokens).
- **Gemini** â€” push massive codebases into 1M token windows.
- **ChatGPT** â€” single-shot analysis without attachments.
- **Cursor / Windsurf** â€” reference the full project in prompts.
- **GitHub Copilot** â€” better context â†’ better suggestions.
- **Local LLMs** â€” datasets for RAG and fine-tuning.

## Built for real projects

- âš¡ **Fast parallel scanning** â€” thousands of files in seconds.
- ğŸ¯ **Smart filtering** â€” respects `.gitignore`, excludes binaries, configurable size limits.
- ğŸ“ **Intentional file order** â€” entry points and configs first, not alphabetical noise.
- ğŸ”„ **Auto-detection** â€” skips files previously generated by `fln`.
- ğŸ“ **Deterministic output** â€” same input â†’ same snapshot.
- ğŸ§  **Project metadata detection** â€” name & version from ecosystem-native manifests.
- ğŸ› ï¸ **Developer-friendly** â€” `Markdown` for humans, `JSON` for tooling, `--dry-run` mode for safety.
- ğŸ”’ **No surprises** â€” runs locally, no data leaves your machine.

Zero dependencies on external services. Zero tracking. Just a tool that does its job.

## Install

```bash
# npm
npm install -g fln

# one-liner (macOS/Linux)
curl -fsSL "https://raw.githubusercontent.com/nesvet/fln/main/install.sh" | sh

# one-liner (Windows)
irm "https://raw.githubusercontent.com/nesvet/fln/main/install.ps1" | iex

# or just run without installing
npx fln . -o codebase.md
```

<details>
<summary>More installation options</summary>

### One-line installer options (macOS/Linux)

Pin a version or custom install directory:

```bash
curl -fsSL "https://raw.githubusercontent.com/nesvet/fln/main/install.sh" | FLN_VERSION="<version>" INSTALL_DIR="$HOME/.local/bin" sh
```

### One-line installer options (Windows PowerShell)

```powershell
$env:FLN_VERSION = "<version>"
$env:INSTALL_DIR = "$env:LOCALAPPDATA\\fln\\bin"
irm "https://raw.githubusercontent.com/nesvet/fln/main/install.ps1" | iex
```

### Manual download (GitHub Releases)

```bash
curl -L "https://github.com/nesvet/fln/releases/latest/download/fln-macos-x64.tar.gz" | tar -xz -C /usr/local/bin
chmod +x /usr/local/bin/fln
fln --help
```

</details>

## Usage

```bash
fln [directory] [options]
```

Examples:

```bash
# Flatten entire project
fln .

# Exclude tests and fixtures
fln src -e "**/*.test.ts" -e "fixtures/"

# Force include a file (even if ignored)
fln . -i "dist/output.md"

# Generate JSON for tooling
fln . --no-contents --format json

# Preview without writing
fln . --dry-run
```

<details>
<summary>All CLI options</summary>

- `-o, --output <path>` Output file or directory
- `-e, --exclude <glob>` Exclude patterns (repeatable)
- `-i, --include <glob>` Force include patterns
- `--include-hidden` Include hidden files and directories
- `--no-gitignore` Ignore `.gitignore`
- `--max-size <size>` Max file size (`10mb`, `512kb`)
- `--max-total-size <size>` Max total included size
- `--no-contents` Exclude file contents
- `--no-tree` Exclude directory tree
- `--format <md|json>` Output format
- `--dry-run` Scan without writing output
- `--follow-symlinks` Follow symlinks
- `--no-ansi` Disable ANSI colors
- `--no-sponsor-message` Hide support message (also: `FLN_NO_SPONSOR=1`)
- `--banner <text>` Add text at the beginning
- `--footer <text>` Add text at the end of the output
- `-q, --quiet` Minimal output
- `-V, --verbose` Verbose output with breakdown
- `--debug` Debug output with file list
- `-v, --version` Show version
- `-h, --help` Show help

</details>

## CI/CD & Automation

Integrate `fln` into your pipeline to keep your codebase â€œAI-readyâ€ automatically.

### GitHub Actions: Auto-generate Snapshots

Generate a fresh `codebase.md` artifact on every push. Download it anytime to chat with LLMs about the *exact* state of your main branch or a specific PR without manual scanning.

Create `.github/workflows/codebase-snapshot.yaml`:

```yaml
name: Snapshot Codebase

on:
  push:
    branches: [ "main" ]
  pull_request:

jobs:
  snapshot:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v6

      - name: Generate Snapshot
        # Generates codebase.md without installing fln globally
        run: npx fln . -o codebase.md --no-ansi

      - name: Upload Artifact
        uses: actions/upload-artifact@v6
        with:
          name: codebase-snapshot
          path: codebase.md
          retention-days: 7
```

### Git Hooks: Pre-commit Context Guard

Prevent accidental â€œcontext bloatâ€ (e.g., committing large datasets or wrong lockfiles) by failing commits if the flattened codebase exceeds a specific size. This ensures your project always fits within LLM context windows.

Add to your pre-commit hook (e.g., via `husky` or `lint-staged`):

```bash
# Fails the commit if the flattened codebase exceeds 5MB (configurable)
# --dry-run ensures no files are written to disk
npx fln . --dry-run --max-total-size 5mb
```

## JavaScript API

```typescript
import { fln } from "fln";

const result = await fln({
  rootDirectory: "./src",
  outputFile: "output.md",
  excludePatterns: [ "*.test.ts", "fixtures/" ],
  format: "md",
  onProgress: (current, total) => {
    console.log(`Progress: ${current}/${total}`);
  }
});

console.log(`Processed ${result.files} files`);
console.log(`Output: ${result.outputPath}`);
console.log(`Tokens: ${result.outputTokenCount}`);
```

All CLI options are available via `FlnOptions`.


## Advanced

<details>
<summary>Configuration file (.fln.json)</summary>

```json
{
	"outputFile": "output.md",
	"excludePatterns": [
		"dist/",
		"**/*.snap"
	],
	"includePatterns": [],
	"includeHidden": false,
	"useGitignore": true,
	"maximumFileSizeBytes": "10mb",
	"maximumTotalSizeBytes": "0",
	"includeTree": true,
	"includeContents": true,
	"format": "md",
	"followSymlinks": false,
	"logLevel": "normal",
	"banner": "This is a snapshot of the codebase.",
	"footer": "End of snapshot."
}
```

</details>

<details>
<summary>Output naming & formats</summary>

- Uses project name + version if available (`package.json`, `pyproject.toml`, `Cargo.toml`, `vcpkg.json`, `go.mod`, or `CMakeLists.txt`)  
- `md` includes tree + contents
- `json` includes `rootDirectory`, `tree`, `stats`

</details>

<details>
<summary>Runtime compatibility</summary>

**Node.js**
- Requires Node.js `>=18.3`
- ESM-only package (`"type": "module"`)
- CLI works via `npm i -g fln` or `npx fln`

**Bun**
- Requires Bun `>=1.0.0`
- CLI works via `bun install -g fln` or `bunx fln`

</details>

## Preview

Full real outputs are provided below. Each example is a compact project in [`examples/`](examples/). `fln` outputs the directory tree and file contents with **entry points and configs first** (intentional file order):

<details>
<summary>TypeScript</summary>

````md
<!-- ğŸ¥ fln 1.0.0 -->

# Codebase Snapshot: ts-app

Generated: 2026-02-08 19:59
Files: 8 | Directories: 2

---

## Directory Tree
```text
â”œâ”€â”€ README.md
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ src
    â”œâ”€â”€ index.ts
    â”œâ”€â”€ config.ts
    â”œâ”€â”€ formatter.ts
    â”œâ”€â”€ processor.ts
    â””â”€â”€ reader.ts
```

---

## Source Files

### README.md
```md
# ts-app

Compact TypeScript example for fln.
```

### package.json
```json
{
	"name": "ts-app",
	"version": "0.1.0",
	"type": "module",
	"description": "Compact TypeScript example project for fln.",
	"scripts": {
		"start": "node ./dist/index.js"
	}
}
```

### tsconfig.json
```json
{
	"compilerOptions": {
		"target": "ES2022",
		"module": "ES2022",
		"moduleResolution": "Bundler",
		"strict": true,
		"outDir": "dist"
	},
	"include": [
		"src/**/*.ts"
	]
}
```

### src/index.ts
```ts
import { loadConfig } from "./config";
import { formatReport } from "./formatter";
import { buildReport } from "./processor";
import { readLines } from "./reader";

async function main(): Promise<void> {
	const config = loadConfig();
	const lines = await readLines(config.inputPath);
	console.log(formatReport(buildReport(config.projectName, lines, config.minLineLength)));
}

void main();
```

### src/config.ts
```ts
export type AppConfig = {
	projectName: string;
	inputPath: string;
	minLineLength: number;
};

export const loadConfig = (): AppConfig => ({
	projectName: "ts-app",
	inputPath: "sample.txt",
	minLineLength: 3
});
```

### src/formatter.ts
```ts
import type { Report } from "./processor";

export const formatReport = (report: Report): string => {
	const lines = [
		`Project: ${report.projectName}`,
		`Lines: ${report.lineCount}`,
		"Filtered:"
	];
	lines.push(...report.filteredLines.map((line) => `- ${line}`));
	return lines.join("\n");
};
```

### src/processor.ts
```ts
export type Report = {
	projectName: string;
	lineCount: number;
	filteredLines: string[];
};

export const buildReport = (
	projectName: string,
	lines: string[],
	minLineLength: number
): Report => {
	const filteredLines = lines.filter((line) => line.length >= minLineLength);
	return {
		projectName,
		lineCount: lines.length,
		filteredLines
	};
};
```

### src/reader.ts
```ts
import { readFile } from "node:fs/promises";

export const readLines = async (path: string): Promise<string[]> => {
	try {
		const content = await readFile(path, "utf-8");
		return content.split("\n").filter((line) => line.trim().length > 0);
	} catch {
		return [ "alpha", "beta", "gamma", "delta" ];
	}
};
```
````
</details>

<details>
<summary>Python</summary>

````md
<!-- ğŸ¥ fln 1.0.0 -->

# Codebase Snapshot: python-app

Generated: 2026-02-08 19:59
Files: 8 | Directories: 3

---

## Directory Tree
```text
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml
â””â”€â”€ src
    â””â”€â”€ python_app
        â”œâ”€â”€ main.py
        â”œâ”€â”€ config.py
        â”œâ”€â”€ __init__.py
        â”œâ”€â”€ formatter.py
        â”œâ”€â”€ processor.py
        â””â”€â”€ reader.py
```

---

## Source Files

### README.md
```md
# python-app

Compact Python example for fln.
```

### pyproject.toml
```toml
[build-system]
requires = ["setuptools>=68.0"]
build-backend = "setuptools.build_meta"

[project]
name = "python-app"
version = "0.1.0"
description = "Compact example project for fln."
readme = "README.md"
requires-python = ">=3.10"

[tool.setuptools.packages.find]
where = ["src"]
```

### src/python_app/main.py
```py
from .config import loadConfig
from .formatter import formatReport
from .processor import buildReport
from .reader import readLines


def run() -> str:
	config = loadConfig()
	lines = readLines(config.inputPath)
	report = buildReport(config.projectName, lines, config.minLineLength)
	return formatReport(report)


def main() -> None:
	print(run())


if __name__ == "__main__":
	main()
```

### src/python_app/config.py
```py
from dataclasses import dataclass


@dataclass(frozen=True)
class AppConfig:
	projectName: str
	inputPath: str
	minLineLength: int


def loadConfig() -> AppConfig:
	return AppConfig(
		projectName="python-app",
		inputPath="sample.txt",
		minLineLength=3
	)
```

### src/python_app/__init__.py
```py
from .main import run

__all__ = ["run"]
```

### src/python_app/formatter.py
```py
from .processor import Report


def formatReport(report: Report) -> str:
	lines = [
		f"Project: {report.projectName}",
		f"Lines: {report.lineCount}",
		"Filtered:"
	]
	lines.extend([f"- {line}" for line in report.filteredLines])
	return "\n".join(lines)
```

### src/python_app/processor.py
```py
from dataclasses import dataclass


@dataclass(frozen=True)
class Report:
	projectName: str
	lineCount: int
	filteredLines: list[str]


def buildReport(projectName: str, lines: list[str], minLineLength: int) -> Report:
	filteredLines = [line for line in lines if len(line) >= minLineLength]
	return Report(
		projectName=projectName,
		lineCount=len(lines),
		filteredLines=filteredLines
	)
```

### src/python_app/reader.py
```py
from pathlib import Path


def readLines(path: str) -> list[str]:
	filePath = Path(path)
	if filePath.is_file():
		return filePath.read_text(encoding="utf-8").splitlines()
	
	return [
		"alpha",
		"beta",
		"gamma",
		"delta"
	]
```
````
</details>

<details>
<summary>Go</summary>

````md
<!-- ğŸ¥ fln 1.0.0 -->

# Codebase Snapshot: go-app

Generated: 2026-02-08 19:59
Files: 7 | Directories: 8

---

## Directory Tree
```text
â”œâ”€â”€ README.md
â”œâ”€â”€ go.mod
â”œâ”€â”€ cmd
â”‚   â””â”€â”€ app
â”‚       â””â”€â”€ main.go
â””â”€â”€ internal
    â”œâ”€â”€ config
    â”‚   â””â”€â”€ config.go
    â”œâ”€â”€ formatter
    â”‚   â””â”€â”€ formatter.go
    â”œâ”€â”€ processor
    â”‚   â””â”€â”€ processor.go
    â””â”€â”€ reader
        â””â”€â”€ reader.go
```

---

## Source Files

### README.md
```md
# go-app

Compact Go example for fln.
```

### go.mod
```mod
module example.com/go-app

go 1.22
```

### cmd/app/main.go
```go
package main

import (
	"fmt"

	"example.com/go-app/internal/config"
	"example.com/go-app/internal/formatter"
	"example.com/go-app/internal/processor"
	"example.com/go-app/internal/reader"
)

func main() {
	appConfig := config.LoadConfig()
	lines := reader.ReadLines(appConfig.InputPath)
	report := processor.BuildReport(appConfig.ProjectName, lines, appConfig.MinLineLength)
	fmt.Println(formatter.FormatReport(report))
}
```

### internal/config/config.go
```go
package config

type Config struct {
	ProjectName   string
	InputPath     string
	MinLineLength int
}

func LoadConfig() Config {
	return Config{
		ProjectName:   "go-app",
		InputPath:     "sample.txt",
		MinLineLength: 3,
	}
}
```

### internal/formatter/formatter.go
```go
package formatter

import (
	"strconv"
	"strings"

	"example.com/go-app/internal/processor"
)

func FormatReport(report processor.Report) string {
	lines := []string{
		"Project: " + report.ProjectName,
		"Lines: " + formatCount(report.LineCount),
		"Filtered:",
	}
	for _, line := range report.FilteredLines {
		lines = append(lines, "- "+line)
	}

	return strings.Join(lines, "\n")
}

func formatCount(value int) string {
	return strconv.Itoa(value)
}
```

### internal/processor/processor.go
```go
package processor

type Report struct {
	ProjectName   string
	LineCount     int
	FilteredLines []string
}

func BuildReport(projectName string, lines []string, minLineLength int) Report {
	filteredLines := make([]string, 0, len(lines))
	for _, line := range lines {
		if len(line) >= minLineLength {
			filteredLines = append(filteredLines, line)
		}
	}

	return Report{
		ProjectName:   projectName,
		LineCount:     len(lines),
		FilteredLines: filteredLines,
	}
}
```

### internal/reader/reader.go
```go
package reader

import (
	"os"
	"strings"
)

func ReadLines(path string) []string {
	content, err := os.ReadFile(path)
	if err != nil {
		return []string{"alpha", "beta", "gamma", "delta"}
	}

	lines := strings.Split(string(content), "\n")
	result := make([]string, 0, len(lines))
	for _, line := range lines {
		if line != "" {
			result = append(result, line)
		}
	}

	return result
}
```
````
</details>

<details>
<summary>Rust</summary>

````md
<!-- ğŸ¥ fln 1.0.0 -->

# Codebase Snapshot: rust-app

Generated: 2026-02-08 19:59
Files: 8 | Directories: 2

---

## Directory Tree
```text
â”œâ”€â”€ README.md
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â”œâ”€â”€ lib.rs
    â”œâ”€â”€ main.rs
    â”œâ”€â”€ config.rs
    â”œâ”€â”€ formatter.rs
    â”œâ”€â”€ processor.rs
    â””â”€â”€ reader.rs
```

---

## Source Files

### README.md
```md
# rust-app

Compact Rust example for fln.
```

### Cargo.toml
```toml
[package]
name = "rust-app"
version = "0.1.0"
edition = "2021"
description = "Compact Rust example project for fln."

[dependencies]
```

### src/lib.rs
```rs
pub mod config;
pub mod formatter;
pub mod processor;
pub mod reader;
```

### src/main.rs
```rs
use rust_app::config::loadConfig;
use rust_app::formatter::formatReport;
use rust_app::processor::buildReport;
use rust_app::reader::readLines;

fn main() {
	let config = loadConfig();
	let lines = readLines(&config.inputPath);
	let report = buildReport(config.projectName, lines, config.minLineLength);
	println!("{}", formatReport(report));
}
```

### src/config.rs
```rs
pub struct AppConfig {
	pub projectName: String,
	pub inputPath: String,
	pub minLineLength: usize,
}

pub fn loadConfig() -> AppConfig {
	AppConfig {
		projectName: "rust-app".to_string(),
		inputPath: "sample.txt".to_string(),
		minLineLength: 3,
	}
}
```

### src/formatter.rs
```rs
use crate::processor::Report;

pub fn formatReport(report: Report) -> String {
	let mut lines = vec![
		format!("Project: {}", report.projectName),
		format!("Lines: {}", report.lineCount),
		"Filtered:".to_string(),
	];
	for line in report.filteredLines {
		lines.push(format!("- {}", line));
	}

	lines.join("\n")
}
```

### src/processor.rs
```rs
pub struct Report {
	pub projectName: String,
	pub lineCount: usize,
	pub filteredLines: Vec<String>,
}

pub fn buildReport(projectName: String, lines: Vec<String>, minLineLength: usize) -> Report {
	let filteredLines = lines
		.iter()
		.filter(|line| line.len() >= minLineLength)
		.map(|line| line.to_string())
		.collect::<Vec<String>>();

	Report {
		projectName,
		lineCount: lines.len(),
		filteredLines,
	}
}
```

### src/reader.rs
```rs
use std::fs;

pub fn readLines(path: &str) -> Vec<String> {
	let content = fs::read_to_string(path);
	if let Ok(text) = content {
		return text
			.lines()
			.filter(|line| !line.trim().is_empty())
			.map(|line| line.to_string())
			.collect();
	}

	vec![
		"alpha".to_string(),
		"beta".to_string(),
		"gamma".to_string(),
		"delta".to_string(),
	]
}
```
````
</details>

## Support this project

**fln is free, open-source, and maintained by one developer.**

If it saves you time or improves your AI workflow:
- â­ï¸ Star the repo â€” it genuinely helps discoverability
- ğŸ’™ Support on [Patreon](https://www.patreon.com/nesvet) â€” priority features & long-term maintenance

## Contributing

PRs and issues are welcome.  
See [`CONTRIBUTING.md`](CONTRIBUTING.md) for setup and guidelines.

## License

MIT
